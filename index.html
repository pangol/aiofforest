<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>숲의 아이 독서모임</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Crimson+Text:wght@400;600;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      color: #333;
      overflow-x: hidden;
      transition: background 0.8s ease;
      position: relative;
      background: transparent;
    }
    
    /* 우주 배경 효과 */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(100, 150, 255, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 100, 150, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(150, 100, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: -2;
    }
    
    /* 섹션별 추가 애니메이션 효과 */
    section {
      transform: scale(0.95);
      opacity: 0;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    section.active {
      transform: scale(1);
      opacity: 1;
    }
    
    /* 섹션 내부 요소들의 추가 애니메이션 */
    section:not(.active) .page-title {
      transform: translateY(50px) scale(0.9);
      opacity: 0.5;
    }
    
    section.active .page-title {
      transform: translateY(0) scale(1);
      opacity: 1;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    section:not(.active) .page-subtitle {
      transform: translateY(30px);
      opacity: 0.3;
    }
    
    section.active .page-subtitle {
      transform: translateY(0);
      opacity: 1;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    /* 멤버 카드들의 추가 애니메이션 */
    section:not(.active) .member-card {
      transform: translateY(100px) rotateY(15deg);
      opacity: 0.3;
    }
    
    section.active .member-card {
      transform: translateY(0) rotateY(0deg);
      opacity: 1;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    /* 프로세스 아이템들의 추가 애니메이션 */
    section:not(.active) .process-item {
      transform: translateX(-100px);
      opacity: 0.3;
    }
    
    section.active .process-item {
      transform: translateX(0);
      opacity: 1;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    /* 폼의 추가 애니메이션 */
    section:not(.active) .contact-form {
      transform: scale(0.8) rotateY(-10deg);
      opacity: 0.3;
    }
    
    section.active .contact-form {
      transform: scale(1) rotateY(0deg);
      opacity: 1;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    /* 섹션 공통 스타일 - sticky 적용 */
    section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 60px 20px;
      position: sticky;
      top: 0;
      overflow: hidden;
      transition: all 0.8s ease;
      background: transparent;
    }
    
    /* 스크롤 기반 애니메이션 클래스들 - 고급 버전 */
    .fade-in {
      opacity: 0;
      transform: translateY(50px);
      transition: all 1.2s cubic-bezier(0.645, 0.045, 0.355, 1);
    }
    
    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .slide-left {
      opacity: 0;
      transform: translateX(-100px) scale(0.95);
      transition: all 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .slide-left.visible {
      opacity: 1;
      transform: translateX(0) scale(1);
    }
    
    .slide-right {
      opacity: 0;
      transform: translateX(100px) scale(0.95);
      transition: all 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .slide-right.visible {
      opacity: 1;
      transform: translateX(0) scale(1);
    }
    
    .scale-in {
      opacity: 0;
      transform: scale(0.8) rotateY(-10deg);
      transition: all 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .scale-in.visible {
      opacity: 1;
      transform: scale(1) rotateY(0deg);
    }
    
    .rotate-in {
      opacity: 0;
      transform: rotateY(-90deg) scale(0.8) translateZ(-100px);
      transition: all 1.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .rotate-in.visible {
      opacity: 1;
      transform: rotateY(0deg) scale(1) translateZ(0);
    }
    
    /* 새로운 고급 애니메이션 클래스들 */
    .elastic-in {
      opacity: 0;
      transform: translateY(100px) scale(0.5);
      transition: all 1.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .elastic-in.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .bounce-in {
      opacity: 0;
      transform: translateY(80px) scale(0.8);
      transition: all 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .bounce-in.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .float-in {
      opacity: 0;
      transform: translateY(60px) rotateX(15deg);
      transition: all 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .float-in.visible {
      opacity: 1;
      transform: translateY(0) rotateX(0deg);
    }
    
    /* 우주 요소들 */
    .space-elements {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    
    /* 별들 */
    .stars {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      animation: twinkle 3s infinite ease-in-out;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
    }
    
    .star:nth-child(odd) {
      animation-duration: 4s;
      animation-delay: 1s;
    }
    
    .star:nth-child(3n) {
      animation-duration: 5s;
      animation-delay: 2s;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    /* 우주선 */
    .spaceship {
      position: absolute;
      width: 40px;
      height: 15px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.1), rgba(100, 200, 255, 0.2), rgba(255, 255, 255, 0.1));
      border-radius: 8px;
      animation: spaceship-fly 12s infinite linear;
      box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
      opacity: 0.6;
    }
    
    .spaceship::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -8px;
      width: 15px;
      height: 3px;
      background: rgba(255, 100, 100, 0.6);
      border-radius: 2px;
      transform: translateY(-50%);
      animation: engine-glow 0.8s infinite alternate;
    }
    
    @keyframes spaceship-fly {
      0% { transform: translateX(-100px) translateY(20vh) rotate(15deg); }
      50% { transform: translateX(50vw) translateY(40vh) rotate(5deg); }
      100% { transform: translateX(calc(100vw + 100px)) translateY(60vh) rotate(-15deg); }
    }
    
    @keyframes engine-glow {
      0% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* 성운 */
    .nebula {
      position: absolute;
      width: 200px;
      height: 150px;
      background: radial-gradient(ellipse, rgba(255, 100, 200, 0.08) 0%, rgba(100, 100, 255, 0.05) 50%, transparent 100%);
      border-radius: 50%;
      animation: nebula-float 25s infinite ease-in-out;
      filter: blur(3px);
      opacity: 0.5;
    }
    
    @keyframes nebula-float {
      0%, 100% { transform: translate(20vw, 30vh) scale(1) rotate(0deg); }
      50% { transform: translate(60vw, 50vh) scale(1.2) rotate(180deg); }
    }
    
    /* 운석 */
    .meteor {
      position: absolute;
      width: 3px;
      height: 20px;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 100, 100, 0.6));
      border-radius: 50%;
      animation: meteor-fall 3s infinite linear;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
    }
    
    @keyframes meteor-fall {
      0% { transform: translateX(100vw) translateY(-50px) rotate(45deg); }
      100% { transform: translateX(-50px) translateY(100vh) rotate(45deg); }
    }
    
    /* 우주 먼지 */
    .space-dust {
      position: absolute;
      width: 1px;
      height: 1px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: dust-float 15s infinite linear;
    }
    
    @keyframes dust-float {
      0% { transform: translateY(100vh) translateX(0); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-50px) translateX(100px); opacity: 0; }
    }
    
    /* 고급 애니메이션 효과 */
    :root {
      --scroll-progress: 0;
      --current-hue: 220;
      --section-hue: 220;
      --section-sat: 70;
      --section-light: 20;
    }
    
    /* 스크롤 기반 동적 효과 */
    .page-title {
      font-family: 'Crimson Text', serif;
      font-size: 8rem;
      font-weight: 700;
      margin-bottom: 40px;
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
      letter-spacing: 4px;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      line-height: 1.1;
    }
    
    .page-title:hover {
      transform: scale(1.05) rotateY(5deg);
      text-shadow: 
        0 8px 16px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(255, 255, 255, 0.4);
    }
    
   
    
    .page-subtitle {
      font-size: 3.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 50px;
      font-weight: 300;
      letter-spacing: 3px;
      animation: subtitleGlow 2s ease-in-out infinite;
      line-height: 1.3;
    }
    
    @keyframes subtitleGlow {
      0%, 100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.3); }
      50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.6); }
    }
    
    /* 멤버 카드 스타일 */
    .members-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 30px;
      max-width: 900px;
      width: 100%;
    }
    
    .member-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.18);
      position: relative;
      overflow: hidden;
      will-change: transform;
      transform-style: preserve-3d;
    }
    
    .member-card::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      animation: cardSparkle 4s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes cardSparkle {
      0%, 100% { 
        transform: rotate(0deg) scale(1);
        opacity: 0.3;
      }
      50% { 
        transform: rotate(180deg) scale(1.1);
        opacity: 0.6;
      }
    }
    
    .member-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.5s;
    }
    
    .member-card:hover::before {
      left: 100%;
    }
    
    .member-card:hover {
      transform: translateY(-15px) scale(1.03) rotateY(8deg) rotateX(2deg);
      box-shadow: 
        0 25px 50px rgba(31, 38, 135, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        0 0 30px rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.18);
      border-color: rgba(255, 255, 255, 0.4);
    }
    
    .member-avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      margin: 0 auto 20px;
      display: block;
      border: 4px solid rgba(255, 255, 255, 0.3);
      box-shadow: 
        0 4px 15px rgba(0,0,0,0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      animation: avatarPulse 2s ease-in-out infinite;
    }
    
    @keyframes avatarPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .member-card:hover .member-avatar {
      transform: scale(1.1);
      border-color: rgba(255, 255, 255, 0.6);
      box-shadow: 
        0 8px 25px rgba(0,0,0,0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    .member-name {
      font-size: 2.5rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.95);
      margin-bottom: 15px;
      transition: color 0.3s ease;
      letter-spacing: 1px;
    }
    
    .member-card:hover .member-name {
      color: rgba(255, 255, 255, 1);
    }
    
    .member-description {
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.6;
      transition: color 0.3s ease;
      font-size: 1.3rem;
      letter-spacing: 0.5px;
    }
    
    .member-card:hover .member-description {
      color: rgba(255, 255, 255, 0.95);
    }
    
    /* 진행 방법 스타일 */
    .process-list {
      max-width: 800px;
      width: 100%;
    }
    
    .process-item {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      margin: 25px 0;
      padding: 35px 40px;
      border-radius: 20px;
      box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border-left: 6px solid rgba(255, 255, 255, 0.5);
      transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      overflow: hidden;
      color: rgba(255, 255, 255, 0.95);
      transform-style: preserve-3d;
      font-size: 1.4rem;
      line-height: 1.6;
      letter-spacing: 0.8px;
    }
    
    .process-item::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 100%;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.2), transparent);
      transition: width 0.3s ease;
    }
    
    .process-item:hover::after {
      width: 100%;
    }
    
    .process-item:hover {
      transform: translateX(15px) scale(1.03) rotateY(3deg);
      box-shadow: 
        0 15px 45px rgba(31, 38, 135, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        0 0 25px rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.18);
      border-left-color: rgba(255, 255, 255, 0.8);
    }
    
    .process-item::before {
      content: "📖";
      font-size: 1.5rem;
      margin-right: 15px;
      animation: bookBounce 1s ease-in-out infinite;
    }
    
    @keyframes bookBounce {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(10deg); }
    }
    
    /* 폼 스타일 */
    .contact-form {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 50px;
      border-radius: 25px;
      box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      max-width: 600px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.18);
      position: relative;
      overflow: hidden;
      transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      transform-style: preserve-3d;
    }
    
    .contact-form:hover {
      transform: scale(1.02) rotateY(2deg);
      box-shadow: 
        0 20px 50px rgba(31, 38, 135, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        0 0 30px rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .contact-form::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      animation: formGlow 4s ease-in-out infinite;
    }
    
    @keyframes formGlow {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(180deg); }
    }
    
    .form-group {
      margin-bottom: 25px;
      position: relative;
      z-index: 1;
    }
    
    .form-input {
      width: 100%;
      padding: 20px 25px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.95);
      transition: all 0.3s ease;
      font-family: inherit;
      position: relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      letter-spacing: 0.5px;
    }
    
    .form-input:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.6);
      box-shadow: 
        0 0 0 3px rgba(255, 255, 255, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.15);
    }
    
    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
      transition: all 0.3s ease;
    }
    
    .form-input:focus::placeholder {
      transform: translateX(10px);
      opacity: 0.7;
    }
    
    .submit-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: rgba(255, 255, 255, 0.95);
      padding: 20px 50px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 30px;
      font-size: 1.4rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
      z-index: 1;
      letter-spacing: 1px;
    }
    
    .submit-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      animation: buttonSparkle 2s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes buttonSparkle {
      0%, 100% { 
        transform: translateX(-100%) translateY(-100%);
        opacity: 0;
      }
      50% { 
        transform: translateX(100%) translateY(100%);
        opacity: 1;
      }
    }
    
    .submit-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .submit-btn:hover::before {
      left: 100%;
    }
    
    .submit-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 
        0 12px 40px rgba(31, 38, 135, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
      color: rgba(255, 255, 255, 1);
    }
    
    /* 스크롤 진행률 표시 - 고급 버전 */
    .scroll-progress {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background: rgba(255,255,255,0.05);
      z-index: 1000;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .scroll-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, 
        hsl(220, 70%, 60%), 
        hsl(240, 75%, 65%), 
        hsl(260, 80%, 70%)
      );
      width: 0%;
      transition: width 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 0 20px rgba(100, 150, 255, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .scroll-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 255, 255, 0.4), 
        transparent
      );
      animation: progressShine 2s ease-in-out infinite;
    }
    
    @keyframes progressShine {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    
    /* 네비게이션 버튼 */
    .nav-buttons {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .nav-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 12px 15px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .nav-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .nav-btn:hover::before {
      left: 100%;
    }
    
    .nav-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 
        0 12px 40px rgba(31, 38, 135, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
      color: rgba(255, 255, 255, 1);
    }
    
    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    /* 텍스트 스플리팅 효과 스타일 */
    .text-split-wrapper {
      display: inline-block;
      overflow: hidden;
    }
    
    .text-char {
      display: inline-block;
      position: relative;
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      transform-origin: center;
    }
    
    .text-char:hover {
      transform: translateY(-5px) scale(1.1) !important;
      color: rgba(255, 255, 255, 1);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    /* 텍스트 스플리팅 애니메이션 클래스들 */
    .text-split-typewriter .text-char {
      opacity: 0;
      transform: translateY(30px) scale(0.8);
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .text-split-typewriter.animate .text-char {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .text-split-bounce .text-char {
      opacity: 0;
      transform: translateY(-50px) scale(0.5);
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .text-split-bounce.animate .text-char {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .text-split-wave .text-char {
      opacity: 0;
      transform: translateY(40px) rotateY(0deg);
      transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .text-split-wave.animate .text-char {
      opacity: 1;
      transform: translateY(0) rotateY(0deg);
    }
    
    .text-split-elastic .text-char {
      opacity: 0;
      transform: translateX(-100px) scale(0.3);
      transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .text-split-elastic.animate .text-char {
      opacity: 1;
      transform: translateX(0) scale(1);
    }
    
    .text-split-fade .text-char {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease-out;
    }
    
    .text-split-fade.animate .text-char {
      opacity: 1;
      transform: translateY(0);
    }
    @media (max-width: 768px) {
      .page-title {
        font-size: 5rem;
        letter-spacing: 2px;
        margin-bottom: 30px;
      }
      
      .page-subtitle {
        font-size: 2.2rem;
        letter-spacing: 2px;
        margin-bottom: 40px;
      }
      
      section {
        padding: 50px 20px;
      }
      
      .members-grid {
        grid-template-columns: 1fr;
        gap: 25px;
      }
      
      .member-name {
        font-size: 2rem;
      }
      
      .member-description {
        font-size: 1.1rem;
      }
      
      .process-item {
        font-size: 1.2rem;
        padding: 30px 25px;
      }
      
      .form-input {
        font-size: 1.1rem;
        padding: 18px 22px;
      }
      
      .submit-btn {
        font-size: 1.3rem;
        padding: 18px 45px;
      }
      
      .nav-buttons {
        bottom: 20px;
        right: 20px;
      }
      
      .nav-btn {
        width: 45px;
        height: 45px;
        font-size: 0.9rem;
      }
    }
   </style>
 </head>
<body>
  <!-- 스크롤 진행률 표시 -->
  <div class="scroll-progress">
    <div class="scroll-progress-bar" id="scrollProgress"></div>
  </div>
  
  <!-- 우주 요소들 -->
  <div class="space-elements" id="spaceElements"></div>
  
  <!-- 섹션 1: 메인 타이틀 -->
  <section id="hero" data-theme="earth-orbit">
    <h1 class="page-title elastic-in text-split-elastic" data-scroll-animation="elastic" data-text-split="elastic">숲의 아이 독서모임</h1>
    <p class="page-subtitle float-in text-split-typewriter" data-scroll-animation="fade" data-text-split="typewriter" id="typing-text">책과 함께 숲처럼 성장하는 시간</p>
  </section>
  
  <!-- 섹션 2: 멤버 소개 -->
  <section id="members" data-theme="mars">
    <h2 class="page-title bounce-in text-split-bounce" data-scroll-animation="bounce" data-text-split="bounce">모임 멤버</h2>
    <div class="members-grid">
      <div class="member-card rotate-in" data-scroll-animation="rotate" data-delay="0.2">
        <img src="https://randomuser.me/api/portraits/women/68.jpg" alt="김나연" class="member-avatar">
        <h3 class="member-name text-split-fade" data-text-split="fade">김나연</h3>
        <p class="member-description text-split-fade" data-text-split="fade">고전문학 애호가, 따뜻한 토론 리더</p>
      </div>
      <div class="member-card rotate-in" data-scroll-animation="rotate" data-delay="0.4">
        <img src="https://randomuser.me/api/portraits/men/42.jpg" alt="이현우" class="member-avatar">
        <h3 class="member-name text-split-fade" data-text-split="fade">이현우</h3>
        <p class="member-description text-split-fade" data-text-split="fade">철학과 인문학 중심, 깊은 질문을 던지는 사람</p>
      </div>
      <div class="member-card rotate-in" data-scroll-animation="rotate" data-delay="0.6">
        <img src="https://randomuser.me/api/portraits/women/32.jpg" alt="박서연" class="member-avatar">
        <h3 class="member-name text-split-fade" data-text-split="fade">박서연</h3>
        <p class="member-description text-split-fade" data-text-split="fade">에세이와 시를 좋아하는 감성적인 멤버</p>
      </div>
    </div>
  </section>
  
  <!-- 섹션 3: 진행 방법 -->
  <section id="process" data-theme="nebula">
    <h2 class="page-title slide-left text-split-wave" data-scroll-animation="slide-left" data-text-split="wave">진행 방법</h2>
    <div class="process-list">
      <div class="process-item slide-left text-split-fade" data-scroll-animation="slide-left" data-text-split="fade" data-delay="0.2">
        매월 지정 도서를 함께 읽고 느낀 점을 나눕니다.
      </div>
      <div class="process-item slide-left text-split-fade" data-scroll-animation="slide-left" data-text-split="fade" data-delay="0.4">
        자유로운 토론과 소그룹 대화로 깊이 있는 대화를 이어갑니다.
      </div>
      <div class="process-item slide-left text-split-fade" data-scroll-animation="slide-left" data-text-split="fade" data-delay="0.6">
        함께 숲속 산책이나 카페 모임을 통해 교류의 장을 만듭니다.
      </div>
      <div class="process-item slide-left text-split-fade" data-scroll-animation="slide-left" data-text-split="fade" data-delay="0.8">
        온라인 기록을 통해 언제든지 다시 읽고 공유할 수 있습니다.
      </div>
    </div>
  </section>
  
  <!-- 섹션 4: 멤버 신청 -->
  <section id="contact" data-theme="deep-space">
    <h2 class="page-title scale-in text-split-elastic" data-scroll-animation="scale" data-text-split="elastic">멤버 신청</h2>
    <form class="contact-form scale-in" data-scroll-animation="scale">
      <div class="form-group">
        <input type="text" class="form-input" placeholder="이름" required>
      </div>
      <div class="form-group">
        <input type="email" class="form-input" placeholder="이메일" required>
      </div>
      <div class="form-group">
        <textarea class="form-input" rows="4" placeholder="참여하고 싶은 이유를 적어주세요" required></textarea>
      </div>
      <button type="submit" class="submit-btn text-split-bounce" data-text-split="bounce">신청하기</button>
    </form>
  </section>
  
  <!-- 네비게이션 버튼 -->
  <div class="nav-buttons">
    <button class="nav-btn" id="prevBtn" title="이전 섹션">↑</button>
    <button class="nav-btn" id="nextBtn" title="다음 섹션">↓</button>
  </div>

  <script>
    // ===== 고급 유틸리티 함수들 =====
    
    // 범위 매핑 함수
    function mapRange(value, inMin, inMax, outMin, outMax) {
      return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
    }
    
    // 클램핑 함수
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    
    // 선형 보간 함수
    function lerp(start, end, factor) {
      return start + (end - start) * factor;
    }
    
    // 고급 Easing 함수들
    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    function easeOut(t) {
      return 1 - Math.pow(1 - t, 3);
    }
    
    function easeIn(t) {
      return t * t * t;
    }
    
    // Elastic easing (탄성 효과)
    function easeElastic(t) {
      return Math.pow(2, -10 * t) * Math.sin((t - 0.075) * (2 * Math.PI) / 0.3) + 1;
    }
    
    // Bounce easing (바운스 효과)
    function easeBounce(t) {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      } else if (t < 2 / 2.75) {
        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      } else if (t < 2.5 / 2.75) {
        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      } else {
        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      }
    }
    
    // Back easing (뒤로 튀는 효과)
    function easeBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    }
    
    // Smooth step (부드러운 단계)
    function smoothStep(t) {
      return t * t * (3 - 2 * t);
    }
    
    // 고급 cubic-bezier 곡선들
    const EASINGS = {
      smooth: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
      elastic: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
      smoothOut: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
      smoothIn: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
      smoothInOut: 'cubic-bezier(0.645, 0.045, 0.355, 1)'
    };
    
    // ===== 고급 파라랙스 스크롤 시스템 =====
    let scrollY = 0;
    let targetScrollY = 0;
    let scrollVelocity = 0;
    let lastScrollY = 0;
    
    // 스크롤 위치 업데이트
    function updateScrollPosition() {
      targetScrollY = window.pageYOffset;
      scrollVelocity = targetScrollY - lastScrollY;
      lastScrollY = targetScrollY;
      
      // 부드러운 스크롤 추적
      scrollY = lerp(scrollY, targetScrollY, 0.1);
    }
    
    // 파라랙스 효과 적용
    function applyParallaxEffect() {
      const elements = document.querySelectorAll('[data-parallax]');
      
      elements.forEach(element => {
        const speed = parseFloat(element.dataset.parallax) || 0.5;
        const yPos = -(scrollY * speed);
        
        element.style.transform = `translateY(${yPos}px)`;
      });
    }
    
    // ===== 고급 애니메이션 시스템 =====
    
    // 텍스트 스플리팅 초기화 및 실행
    function initializeTextSplitting() {
      const textSplitElements = document.querySelectorAll('[data-text-split]');
      
      textSplitElements.forEach(element => {
        const effect = element.dataset.textSplit || 'typewriter';
        createAdvancedTextSplit(element, effect);
      });
    }
    
    // 텍스트 스플리팅 애니메이션 실행
    function runTextSplittingAnimations() {
      const textSplitElements = document.querySelectorAll('[data-text-split]');
      
      textSplitElements.forEach(element => {
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        // 요소가 화면에 보이는지 확인
        if (rect.top < windowHeight && rect.bottom > 0) {
          const effect = element.dataset.textSplit || 'typewriter';
          runTextSplitAnimation(element, effect);
        }
      });
    }
    
    // 스크롤 기반 애니메이션 업데이트
    function updateScrollAnimations() {
      const animatedElements = document.querySelectorAll('[data-scroll-animation]');
      
      animatedElements.forEach(element => {
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        // 요소가 화면에 얼마나 보이는지 계산
        const elementTop = rect.top;
        const elementHeight = rect.height;
        const elementBottom = rect.bottom;
        
        // 요소가 화면에 들어오는 정도 (0~1)
        let progress = 0;
        
        if (elementTop < windowHeight && elementBottom > 0) {
          progress = (windowHeight - elementTop) / (windowHeight + elementHeight);
          progress = clamp(progress, 0, 1);
        }
        
        // 애니메이션 타입에 따른 효과 적용
        const animationType = element.dataset.scrollAnimation || 'fade';
        applyScrollAnimation(element, animationType, progress);
        
        // 텍스트 스플리팅 효과도 함께 실행
        if (element.dataset.textSplit && progress > 0.3) {
          const effect = element.dataset.textSplit;
          runTextSplitAnimation(element, effect);
        }
      });
    }
    
    // 스크롤 애니메이션 적용
    function applyScrollAnimation(element, type, progress) {
      const easedProgress = easeOut(progress);
      
      switch (type) {
        case 'fade':
          element.style.opacity = easedProgress;
          element.style.transform = `translateY(${30 * (1 - easedProgress)}px)`;
          break;
          
        case 'slide-left':
          element.style.opacity = easedProgress;
          element.style.transform = `translateX(${-50 * (1 - easedProgress)}px)`;
          break;
          
        case 'slide-right':
          element.style.opacity = easedProgress;
          element.style.transform = `translateX(${50 * (1 - easedProgress)}px)`;
          break;
          
        case 'scale':
          element.style.opacity = easedProgress;
          element.style.transform = `scale(${0.8 + 0.2 * easedProgress})`;
          break;
          
        case 'rotate':
          element.style.opacity = easedProgress;
          element.style.transform = `rotateY(${-90 * (1 - easedProgress)}deg) scale(${0.8 + 0.2 * easedProgress})`;
          break;
          
        case 'elastic':
          element.style.opacity = easedProgress;
          element.style.transform = `translateY(${30 * (1 - easeElastic(progress))}px) scale(${0.9 + 0.1 * easeElastic(progress)})`;
          break;
          
        case 'bounce':
          element.style.opacity = easedProgress;
          element.style.transform = `translateY(${20 * (1 - easeBounce(progress))}px)`;
          break;
      }
    }
    
    // ===== 마우스 추적 시스템 =====
    let mouseX = 0.5;
    let mouseY = 0.5;
    let targetMouseX = 0.5;
    let targetMouseY = 0.5;
    
    // 마우스 이벤트 처리
    function updateMouse(e) {
      targetMouseX = e.clientX / window.innerWidth;
      targetMouseY = e.clientY / window.innerHeight;
    }
    
    function updateMouseLerp() {
      mouseX = lerp(mouseX, targetMouseX, 0.1);
      mouseY = lerp(mouseY, targetMouseY, 0.1);
    }
    
    // ===== 고급 스크롤 진행률 시스템 =====
    let scrollProgress = 0;
    let targetScrollProgress = 0;
    
    function updateScrollProgress() {
      const scrollTop = window.pageYOffset;
      const docHeight = document.body.scrollHeight - window.innerHeight;
      const scrollPercent = (scrollTop / docHeight) * 100;
      
      targetScrollProgress = clamp(scrollPercent, 0, 100);
      scrollProgress = lerp(scrollProgress, targetScrollProgress, 0.15);
      
      // 부드러운 진행률 표시
      const progressBar = document.getElementById('scrollProgress');
      if (progressBar) {
        progressBar.style.width = scrollProgress + '%';
        
        // 스크롤 속도에 따른 색상 변화
        const speed = Math.abs(scrollVelocity);
        const intensity = clamp(speed / 10, 0, 1);
        const hue = lerp(200, 280, intensity);
        const saturation = lerp(60, 80, intensity);
        const lightness = lerp(50, 70, intensity);
        
        progressBar.style.background = `linear-gradient(90deg, 
          hsl(${hue}, ${saturation}%, ${lightness}%), 
          hsl(${hue + 20}, ${saturation}%, ${lightness + 10}%), 
          hsl(${hue + 40}, ${saturation}%, ${lightness + 20}%)
        )`;
      }
      
      // 스크롤 기반 고급 효과
      const scrollFactor = mapRange(scrollProgress, 0, 100, 0, 1);
      const easedScroll = easeInOut(scrollFactor);
      
      // 배경 색상 변화 (lerp 사용)
      const baseHue = 220;
      const targetHue = 280;
      const currentHue = lerp(baseHue, targetHue, easedScroll);
      
      // 문서 전체에 스크롤 기반 스타일 적용
      document.documentElement.style.setProperty('--scroll-progress', easedScroll);
      document.documentElement.style.setProperty('--current-hue', currentHue);
    }
    
    // ===== WebGL Shader 시스템 =====
    let gl;
    let shaderProgram;
    let canvas;
    let time = 0;
    
    // WebGL 초기화
    function initWebGL() {
      try {
        canvas = document.createElement('canvas');
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '-3';
        canvas.style.pointerEvents = 'none';
        document.body.appendChild(canvas);
        
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
          console.log('WebGL not supported, using CSS background instead');
          return;
        }
        
        // Canvas 크기 설정
        function resizeCanvas() {
          canvas.width = window.innerWidth * window.devicePixelRatio;
          canvas.height = window.innerHeight * window.devicePixelRatio;
          gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Shader 소스
        const vertexShaderSource = `
          attribute vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        
        const fragmentShaderSource = `
          precision highp float;
          uniform float u_time;
          uniform vec2 u_resolution;
          uniform vec2 u_mouse;
          
          // 노이즈 함수
          float noise(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
          }
          
          float fbm(vec2 p) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            for (int i = 0; i < 5; i++) {
              value += amplitude * noise(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
            }
            return value;
          }
          
          void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 p = uv * 3.0;
            
            // 마우스 위치에 따른 왜곡
            vec2 mouseEffect = (u_mouse - 0.5) * 0.1;
            p += mouseEffect * sin(u_time * 0.5);
            
            // 노이즈 기반 우주 배경
            float n1 = fbm(p + u_time * 0.1);
            float n2 = fbm(p * 2.0 + u_time * 0.15);
            float n3 = fbm(p * 4.0 + u_time * 0.2);
            
            // 색상 계산
            vec3 color1 = vec3(0.1, 0.2, 0.4); // 어두운 파랑
            vec3 color2 = vec3(0.3, 0.1, 0.5); // 보라
            vec3 color3 = vec3(0.1, 0.1, 0.2); // 매우 어두운 파랑
            
            vec3 finalColor = mix(color1, color2, n1);
            finalColor = mix(finalColor, color3, n2);
            finalColor += n3 * 0.1; // 별빛 효과
            
            // 마우스 위치에 따른 색상 변화
            float mouseDist = distance(uv, u_mouse);
            vec3 mouseColor = vec3(0.5, 0.3, 0.8);
            finalColor = mix(finalColor, mouseColor, smoothstep(0.5, 0.0, mouseDist) * 0.3);
            
            gl_FragColor = vec4(finalColor, 1.0);
          }
        `;
        
        // Shader 컴파일 및 링크
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        if (!vertexShader || !fragmentShader) {
          console.error('Shader compilation failed');
          return;
        }
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          console.error('Shader program link error:', gl.getProgramInfoLog(shaderProgram));
          return;
        }
        
        // 사각형 버퍼 생성
        const positions = new Float32Array([
          -1, -1,
           1, -1,
          -1,  1,
           1,  1
        ]);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // 렌더링 루프 시작
        render();
        
      } catch (error) {
        console.error('WebGL initialization error:', error);
      }
    }
    
    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      
      return shader;
    }
    
    function render() {
      if (!shaderProgram) {
        console.error('Shader program not available');
        return;
      }
      
      time += 0.016; // 약 60fps
      
      gl.useProgram(shaderProgram);
      
      // Uniform 설정
      const timeLocation = gl.getUniformLocation(shaderProgram, 'u_time');
      const resolutionLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
      const mouseLocation = gl.getUniformLocation(shaderProgram, 'u_mouse');
      
      if (timeLocation !== null) gl.uniform1f(timeLocation, time);
      if (resolutionLocation !== null) gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      if (mouseLocation !== null) gl.uniform2f(mouseLocation, mouseX, mouseY);
      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      
      requestAnimationFrame(render);
    }
    
    // 마우스 이벤트 처리
    function updateMouse(e) {
      targetMouseX = e.clientX / window.innerWidth;
      targetMouseY = e.clientY / window.innerHeight;
    }
    
    function updateMouseLerp() {
      mouseX = lerp(mouseX, targetMouseX, 0.1);
      mouseY = lerp(mouseY, targetMouseY, 0.1);
    }
    
    // ===== 고급 텍스트 스플리팅 시스템 =====
    
    // 텍스트를 개별 문자로 분할하는 함수
    function splitText(element) {
      const text = element.textContent;
      element.innerHTML = '';
      
      const wrapper = document.createElement('span');
      wrapper.className = 'text-split-wrapper';
      wrapper.style.display = 'inline-block';
      
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const charSpan = document.createElement('span');
        charSpan.className = 'text-char';
        charSpan.textContent = char === ' ' ? '\u00A0' : char; // 공백 처리
        charSpan.style.display = 'inline-block';
        charSpan.style.opacity = '0';
        charSpan.style.transform = 'translateY(50px) rotateX(-90deg)';
        charSpan.style.transition = `all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) ${i * 0.05}s`;
        wrapper.appendChild(charSpan);
      }
      
      element.appendChild(wrapper);
      return wrapper;
    }
    
    // 텍스트 스플리팅 애니메이션 활성화
    function activateTextSplit(element) {
      const wrapper = element.querySelector('.text-split-wrapper');
      if (wrapper) {
        const chars = wrapper.querySelectorAll('.text-char');
        chars.forEach(char => {
          char.style.opacity = '1';
          char.style.transform = 'translateY(0) rotateX(0deg)';
        });
      }
    }
    
    // 텍스트 스플리팅 애니메이션 비활성화
    function deactivateTextSplit(element) {
      const wrapper = element.querySelector('.text-split-wrapper');
      if (wrapper) {
        const chars = wrapper.querySelectorAll('.text-char');
        chars.forEach(char => {
          char.style.opacity = '0';
          char.style.transform = 'translateY(50px) rotateX(-90deg)';
        });
      }
    }
    
    // 고급 텍스트 스플리팅 효과
    function createAdvancedTextSplit(element, effect = 'typewriter') {
      const text = element.textContent;
      element.innerHTML = '';
      
      const wrapper = document.createElement('span');
      wrapper.className = 'text-split-wrapper';
      wrapper.style.display = 'inline-block';
      
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const charSpan = document.createElement('span');
        charSpan.className = 'text-char';
        charSpan.textContent = char === ' ' ? '\u00A0' : char;
        charSpan.style.display = 'inline-block';
        charSpan.style.opacity = '0';
        
        // 효과별 초기 상태 설정
        switch (effect) {
          case 'typewriter':
            charSpan.style.transform = 'translateY(30px) scale(0.8)';
            charSpan.style.transition = `all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) ${i * 0.08}s`;
            break;
            
          case 'bounce':
            charSpan.style.transform = 'translateY(-50px) scale(0.5)';
            charSpan.style.transition = `all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) ${i * 0.06}s`;
            break;
            
          case 'wave':
            charSpan.style.transform = `translateY(40px) rotateY(${Math.sin(i * 0.5) * 30}deg)`;
            charSpan.style.transition = `all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${i * 0.04}s`;
            break;
            
          case 'elastic':
            charSpan.style.transform = 'translateX(-100px) scale(0.3)';
            charSpan.style.transition = `all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) ${i * 0.03}s`;
            break;
            
          case 'fade':
            charSpan.style.transform = 'translateY(20px)';
            charSpan.style.transition = `all 0.3s ease-out ${i * 0.02}s`;
            break;
            
          default:
            charSpan.style.transform = 'translateY(30px)';
            charSpan.style.transition = `all 0.4s ease-out ${i * 0.05}s`;
        }
        
        wrapper.appendChild(charSpan);
      }
      
      element.appendChild(wrapper);
      return wrapper;
    }
    
    // 텍스트 스플리팅 애니메이션 실행
    function runTextSplitAnimation(element, effect = 'typewriter') {
      const wrapper = element.querySelector('.text-split-wrapper');
      if (wrapper) {
        const chars = wrapper.querySelectorAll('.text-char');
        chars.forEach(char => {
          char.style.opacity = '1';
          char.style.transform = 'translateY(0) scale(1) rotateY(0deg)';
        });
      }
    }
    
    // 타이핑 효과
    const texts = [
      "책과 함께 숲처럼 성장하는 시간",
      "지혜의 나무 아래서 만나는 이야기",
      "마음의 숲을 가꾸는 독서 여행"
    ];
    const typingEl = document.getElementById("typing-text");
    let textIndex = 0;
    let charIndex = 0;
    let isDeleting = false;
    
    function typeWriter() {
      const currentText = texts[textIndex];
      
      if (isDeleting) {
        typingEl.innerHTML = currentText.substring(0, charIndex - 1);
        charIndex--;
      } else {
        typingEl.innerHTML = currentText.substring(0, charIndex + 1);
        charIndex++;
      }
      
      let typeSpeed = 120;
      
      if (isDeleting) {
        typeSpeed /= 2;
      }
      
      if (!isDeleting && charIndex === currentText.length) {
        typeSpeed = 2000;
        isDeleting = true;
      } else if (isDeleting && charIndex === 0) {
        isDeleting = false;
        textIndex = (textIndex + 1) % texts.length;
        typeSpeed = 500;
      }
      
      setTimeout(typeWriter, typeSpeed);
    }
    
    setTimeout(typeWriter, 1000);
    
    // 스크롤 진행률 업데이트 - 고급 버전
    function updateScrollProgress() {
      const scrollTop = window.pageYOffset;
      const docHeight = document.body.scrollHeight - window.innerHeight;
      const scrollPercent = (scrollTop / docHeight) * 100;
      
      // mapRange를 사용한 부드러운 진행률
      const smoothProgress = mapRange(scrollPercent, 0, 100, 0, 100);
      document.getElementById('scrollProgress').style.width = smoothProgress + '%';
      
      // 스크롤 기반 고급 효과
      const scrollFactor = mapRange(scrollPercent, 0, 100, 0, 1);
      const easedScroll = easeInOut(scrollFactor);
      
      // 배경 색상 변화 (lerp 사용)
      const baseHue = 220;
      const targetHue = 280;
      const currentHue = lerp(baseHue, targetHue, easedScroll);
      
      // 문서 전체에 스크롤 기반 스타일 적용
      document.documentElement.style.setProperty('--scroll-progress', easedScroll);
      document.documentElement.style.setProperty('--current-hue', currentHue);
    }
    
    // Intersection Observer 설정
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const element = entry.target;
          const delay = element.dataset.delay || 0;
          
          setTimeout(() => {
            element.classList.add('visible');
          }, delay * 1000);
        }
      });
    }, observerOptions);
    
    // 애니메이션 요소들 관찰 시작
    document.addEventListener('DOMContentLoaded', () => {
      const animatedElements = document.querySelectorAll('.fade-in, .slide-left, .slide-right, .scale-in, .rotate-in');
      animatedElements.forEach(el => observer.observe(el));
    });
    
    // 스크롤 이벤트 리스너 - 고급 버전
    window.addEventListener('scroll', () => {
      updateScrollPosition();
      updateScrollProgress();
      updateScrollAnimations();
      applyParallaxEffect();
      updateMouseLerp();
    });
    
    // 마우스 이벤트 리스너
    window.addEventListener('mousemove', updateMouse);
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updateMouse(touch);
    });
    
    // 배경 그라데이션 업데이트 - 통일된 우주 배경
    function updateBackgroundGradient() {
      // 고정된 우주 배경 사용
      document.body.style.background = `radial-gradient(ellipse at center, #0a0a1a 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%)`;
    }
    
    // 네비게이션 버튼 기능
    const sections = document.querySelectorAll('section');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    let currentSectionIndex = 0;
    
    function updateNavigation() {
      prevBtn.disabled = currentSectionIndex === 0;
      nextBtn.disabled = currentSectionIndex === sections.length - 1;
    }
    
    function scrollToSection(index) {
      sections[index].scrollIntoView({ behavior: 'smooth' });
      currentSectionIndex = index;
      updateNavigation();
    }
    
    prevBtn.addEventListener('click', () => {
      if (currentSectionIndex > 0) {
        scrollToSection(currentSectionIndex - 1);
      }
    });
    
    nextBtn.addEventListener('click', () => {
      if (currentSectionIndex < sections.length - 1) {
        scrollToSection(currentSectionIndex + 1);
      }
    });
    
    // 키보드 네비게이션
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'PageDown') {
        e.preventDefault();
        if (currentSectionIndex < sections.length - 1) {
          scrollToSection(currentSectionIndex + 1);
        }
      } else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
        e.preventDefault();
        if (currentSectionIndex > 0) {
          scrollToSection(currentSectionIndex - 1);
        }
      }
    });
    
    // 스크롤 위치에 따른 현재 섹션 업데이트 - sticky 애니메이션
    function updateCurrentSection() {
      const scrollTop = window.pageYOffset;
      const windowHeight = window.innerHeight;
      
      sections.forEach((section, index) => {
        const sectionTop = section.offsetTop;
        const sectionHeight = section.offsetHeight;
        
        // 섹션이 화면 중앙에 있을 때 활성화
        if (scrollTop >= sectionTop - windowHeight / 2 && 
            scrollTop < sectionTop + sectionHeight - windowHeight / 2) {
          
          // 모든 섹션에서 active 클래스 제거
          sections.forEach(s => s.classList.remove('active'));
          
          // 현재 섹션에 active 클래스 추가
          section.classList.add('active');
          
          currentSectionIndex = index;
          updateNavigation();
          updateSpaceEnvironment(index);
        }
      });
    }
    
    window.addEventListener('scroll', updateCurrentSection);
    
              // 우주 요소들 생성
    function createSpaceElements() {
      const spaceContainer = document.getElementById('spaceElements');
      
      // 별들 생성
      const starsContainer = document.createElement('div');
      starsContainer.className = 'stars';
      for (let i = 0; i < 80; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        starsContainer.appendChild(star);
      }
      spaceContainer.appendChild(starsContainer);
      
      // 우주선 생성
      const spaceship = document.createElement('div');
      spaceship.className = 'spaceship';
      spaceContainer.appendChild(spaceship);
      
      // 성운 생성
      const nebula = document.createElement('div');
      nebula.className = 'nebula';
      spaceContainer.appendChild(nebula);
      
      // 운석들 생성
      for (let i = 0; i < 3; i++) {
        const meteor = document.createElement('div');
        meteor.className = 'meteor';
        meteor.style.animationDelay = Math.random() * 5 + 's';
        meteor.style.left = Math.random() * 100 + '%';
        spaceContainer.appendChild(meteor);
      }
      
      // 우주 먼지 생성
      for (let i = 0; i < 20; i++) {
        const dust = document.createElement('div');
        dust.className = 'space-dust';
        dust.style.left = Math.random() * 100 + '%';
        dust.style.animationDelay = Math.random() * 15 + 's';
        spaceContainer.appendChild(dust);
      }
    }
    
    // 섹션별 우주 환경 업데이트 - 고급 버전
    function updateSpaceEnvironment(sectionIndex) {
      const themes = ['earth-orbit', 'mars', 'nebula', 'deep-space'];
      const currentTheme = themes[sectionIndex];
      
      // mapRange를 사용한 섹션별 효과
      const sectionProgress = mapRange(sectionIndex, 0, themes.length - 1, 0, 1);
      const easedProgress = easeInOut(sectionProgress);
      
      // 섹션별 색상 테마 (lerp 사용)
      const sectionColors = [
        { hue: 220, sat: 70, light: 20 }, // 지구 궤도 - 파랑
        { hue: 0, sat: 80, light: 25 },   // 화성 - 빨강
        { hue: 280, sat: 60, light: 30 }, // 성운 - 보라
        { hue: 240, sat: 50, light: 15 }  // 깊은 우주 - 어두운 파랑
      ];
      
      const currentColor = sectionColors[sectionIndex];
      const nextColor = sectionColors[Math.min(sectionIndex + 1, themes.length - 1)];
      
      // 부드러운 색상 전환
      const lerpedHue = lerp(currentColor.hue, nextColor.hue, easedProgress);
      const lerpedSat = lerp(currentColor.sat, nextColor.sat, easedProgress);
      const lerpedLight = lerp(currentColor.light, nextColor.light, easedProgress);
      
      // 문서에 CSS 변수 설정
      document.documentElement.style.setProperty('--section-hue', lerpedHue);
      document.documentElement.style.setProperty('--section-sat', lerpedSat);
      document.documentElement.style.setProperty('--section-light', lerpedLight);
      
      // 우주 요소들 업데이트
      const spaceContainer = document.getElementById('spaceElements');
      spaceContainer.innerHTML = '';
      createSpaceElements();
    }
    
    // 추가 우주 애니메이션
    const style = document.createElement('style');
    style.textContent = `
      /* 행성 애니메이션 제거됨 */
    `;
    document.head.appendChild(style);
    
    // 폼 제출 처리
     document.querySelector('.contact-form').addEventListener('submit', function(e) {
       e.preventDefault();
       alert('신청이 완료되었습니다! 곧 연락드리겠습니다.');
     });
     
             // 초기화 - 고급 버전
    document.addEventListener('DOMContentLoaded', () => {
      // WebGL 초기화
      initWebGL();
      
      // 텍스트 스플리팅 초기화
      initializeTextSplitting();
      
      // 기존 초기화
      createSpaceElements();
      updateNavigation();
      updateScrollProgress();
      updateSpaceEnvironment(0);
      
      // 첫 번째 섹션 활성화
      sections[0].classList.add('active');
      
      // 마우스 추적 시작
      setInterval(updateMouseLerp, 16); // 60fps
      
      // 고급 애니메이션 시스템 시작
      requestAnimationFrame(function animate() {
        updateScrollAnimations();
        applyParallaxEffect();
        runTextSplittingAnimations();
        requestAnimationFrame(animate);
      });
    });
  </script>
</body>
</html>
